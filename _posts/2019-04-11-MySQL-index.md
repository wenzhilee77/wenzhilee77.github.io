---
layout: post
title:  MySQL index
categories: MySQL index
tags:  MySQL index
author: wenzhilee77
---

# MySQL 存储引擎

## InnoDB

InnoDB 是 MySQL 5.5 之后默认的存储引擎，它具有高可靠、高性能的特点，主要具备以下优势：

* DML 操作完全遵循 ACID 模型，支持事务，支持崩溃恢复，能够极大地保护用户的数据安全；
* 支持多版本并发控制，它会保存数据的旧版本信息，从而可以支持并发和事务的回滚；
* 支持行级锁，支持类似 Oracle 的一致性读的特性，从而可以承受高并发地访问；
* InnoDB 组织数据时默认按照主键进行聚簇，从而可以提高主键查找的效率。对于频繁访问的数据，InnoDB 还会为其建立哈希索引，从而提高等值查询的效率，这也称为自适应哈希索引；
* InnoDB 基于磁盘进行存储，所有存储记录按 页 的方式进行管理。为弥补 CPU 速度与磁盘速度之间的鸿沟，InnoDB 引用缓存池 (Buffer Pool) 来提高数据的整体性能。查询时，会将目标页读入缓存中；修改时，会先修改缓冲池中的页，然后再遵循 CheckPoint 机制将页刷回磁盘。所有缓存页通过最近最少使用原则 ( LRU ) 来进行定期清理。
* InnoDB 支持两次写 (DoubleWrite) ，从而可以保证数据的安全，提高系统的可靠性。

一个 InnoDB 引擎完整的内存结构和磁盘结构如下图所示：

![](/images/index/001.jpg)

## MyISAM

MyISAM 是 MySQL 5.5 之前默认的存储引擎。创建 MyISAM 表时会创建两个同名的文件：

* 扩展名为 .MYD（MYData）：用于存储表数据；
* 扩展名为 .MYI （MYIndex）： 用于存储表的索引信息。

在 MySQL 8.0 之后，只会创建上述两个同名文件，因为 8.0 后表结构的定义存储在 MySQL 数据字典中，但在 MySQL 8.0 之前，还会存在一个扩展名为 .frm 的文件，用于存储表结构信息。MyISAM 与 InnoDB 主要的区别其只支持表级锁，不支持行级锁，不支持事务，不支持自动崩溃恢复，但可以使用内置的 mysqlcheck 和 myisamchk 工具来进行检查和修复。

# MySQL 索引

## B+ tree 数据结构

如果没有特殊说明，通常大多数数据库采用的索引都是 B+ tree 索引，它是基于 B+ tree 这种数据结构构建的。为什么采用 B+ tree 而不是平衡二叉树 (AVL) 或红黑树等数据结构？这里假设索引为 1-16 的自增数据，各类数据结构的表现如下：

**平衡二叉树数据结构：**

![](/images/index/002.jpg)

**红黑树数据结构：**

![](/images/index/003.jpg)

**Btree 数据结构：**

![](/images/index/004.jpg)

**B+ Tree 数据结构**

![](/images/index/005.jpg)

从上面的图示中我们可以看出 B+ Tree 树具有以下优点：
* B+ Tree 树的所有非叶子节点 (如 003，007)，都会在叶子节点冗余一份，所有叶子节点都按照链表的方式进行组织，这样带来的好处是在范围查询中，只需要通过遍历叶子节点就可以获取到所有的索引信息。
* B+ Tree 的所有非叶子节点都可以存储多个数据值，这取决于节点的大小，在 MySQL 中每个节点的大小为 16K ，因此其具备更大的出度，即在相同的数据量下，其树的高度更低。
* 所有非叶子节点都只存储索引值，不存储实际的数据，只有叶子节点才会存储指针信息或数据信息。按照每个节点为 16K 的大小计算，对于千万级别的数据，其树的高度通常都在 3~6 左右 (取决于索引值的字节数)，因此其查询性能非常优异。
* 叶子节点存储的数据取决于不同数据库的实现，对于 MySQL 来说，取决于使用的存储引擎和是否是主键索引。

## B+ tree 索引

对于 InnoDB ，因为主键索引是聚集索引，所以其叶子节点存储的就是实际的数据。而非主键索引存储的则是主键的值 ：

![](/images/index/006.jpg)

对于 MyISAM，因为主键索引是非聚集索引，所以其叶子节点存储的只是指向数据位置的指针：

![](/images/index/007.jpg)

综上所述，B+ tree 结构普遍适用于范围查找，优化排序和分组等操作。B+ tree 是基于字典序进行构建的，因此其适用于以下查询：

+ **全值匹配：** 以索引为条件进行精确查找。如 emp_no 字段为索引，查询条件为 emp_no = 10008。
+ **前缀匹配：** 以联合索引的前缀为查找条件。如 emp_no 和 dept_no 为联合索引，查找条件为  emp_no = 10008。
+ **列前缀匹配：** 匹配索引列的值的开头部分。如 dept_no 为索引，查询条件为  dept_no like "d1%"。前缀匹配和列前缀匹配都是索引前缀性的体现，在某些时候也称为前缀索引。
+ **匹配范围值：** 按照索引列匹配一定范围内的值。如 emp_no 字段为索引，查询条件为  emp_no > 10008。
+ **只访问索引的查询：** 如 emp_no 字段为索引，查询语句为  select emp_no from employees，此时 emp_no 索引被称为本次查询的覆盖索引，即只需要从索引上就可以获取全部的查询信息，而不必访问实际的表中的数据。
+ **精确匹配某一列并范围匹配某一列：** 如 emp_no 和 dept_no 为联合索引，查找条件为  dept_no = "d004" and emp_no < 10020，这种情况下索引顺序必须为 (dept_no, emp_no)，这样才能基于 emp_no 的字典序排序进行范围查找。

## 哈希索引

使用哈希索引时，存储引擎会对索引列的值进行哈希运算，并将计算出的哈希值和指向该行数据的指针存储在索引中，因此它更适用于等值比较查询，而不是范围查询，同样也不能用于优化排序和分组等操作。在建立哈希索引时，需要选取选择性比较高的列，即列上的数据不容易重复 (如身份证号)，这样可以尽量避免哈希冲突。因为哈希索引并不需要存储索引列的数据，所以其结构比较紧凑，对应的查询速度也比较快。

InnoDB 引擎有一个名为 “自适应哈希索引 (adaptive hash index)” 的功能，当某些索引值被频繁使用时，它会在内存中基于 B+ tree 索引再创建一个哈希索引，从而让 B-Tree 索引具备哈希索引快速查找的优点。

## 索引的优点

* 索引极大减少了服务器需要扫描的数据量；
* 索引可以帮助服务器避免排序和临时表；
* 索引可以将随机 IO 转换为顺序 IO。

## 使用策略

* 在查询时，应该避免在索引列上使用函数或者表达式。
* 对于多列索引，应该按照使用频率由高到低的顺序建立联合索引。
* 尽量避免创建冗余的索引。如存在索引 (A，B)，接着又创建了索引 A，因为索引 A 是索引 (A，B) 的前缀索引，从而出现冗余。
* 建立索引时，应该考虑查询时候的排序和分组的需求。只有当索引列的顺序和 ORDER BY 字句的顺序完全一致，并且遵循同样的升序或降序规则时候，MySQL 才会使用索引来对结果做排序。


# 参考

https://juejin.im/post/5e0db3a05188253a570493a1?utm_source=gold_browser_extension#heading-23